:uri-package-docs: https://pkl-lang.org/package-docs
:uri-bindings-specification: {uri-docs}/bindings-specification/binary-encoding.html
:uri-stdlib-baseModule: {uri-package-docs}/pkl/current/base
:uri-stdlib-Annotation: {uri-stdlib-baseModule}/Annotation
:uri-stdlib-BaseValueRenderer: {uri-stdlib-baseModule}/BaseValueRenderer
:uri-stdlib-Typed: {uri-stdlib-baseModule}/Typed
:uri-stdlib-Pair: {uri-stdlib-baseModule}/Pair
:uri-stdlib-RenderDirective: {uri-stdlib-baseModule}/RenderDirective

= Annotation converters

* Proposal: link:./SPICE-0024-annotation-converters.adoc[SPICE-0024]
* Author: https://github.com/HT154[Jen Basch]
* Status: TBD
* Implemented in: Pkl 0.31
* Category: Language, Standard Library

== Introduction

This proposal introduces a mechanisms to use link:{uri-stdlib-Annotation}[`Annotations`] in link:{uri-stdlib-BaseValueRenderer}[value renderers] to declaratively transform property names and values of link:{uri-stdlib-Typed}[`Typed`] objects during rendering

== Motivation

Today, Pkl's renderers (subclasses of link:{uri-stdlib-BaseValueRenderer}[`BaseValueRenderer`]) offer link:{uri-stdlib-BaseValueRenderer}#converters[`converters`] to transform values during rendering based on their class or "path" through the rendered value.
This functionality is fairly flexible, but there are some use cases that remain difficult or impossible to achieve:

* *Transforming property names* is possible, but only by using a converter on the surrounding value, converting it to a `Map`, and transforming entries.
+
[source,pkl]
----
class Bird {
  birdName: String
}

output {
  renderer {
    converters {
      // replace "birdName" with "bird_name"
      [Bird] = (it) ->
        it
          .toMap()
          .mapKeys((name) ->
            name.replaceAllMapped(Regex("([a-z0-9])([A-Z])"), (match) ->
              "\(match.groups[1].value)_\(match.groups[2].value.toLowerCase())"
            )
          )
    }
  }
}
----
* *Converting the same type in different ways* is possible in some cases using path-based converters or by converting containing classes.
Both of these approaches separate the presentation from the definition, making the code more difficult to understand and maintain.
+
[source,pkl]
----
clientConfig: ClientConfig

serverConfig: ServerConfig

class ClientConfig {
  timeoutS: Duration // render as seconds
}

class ServerConfig {
  readTimeoutS: Duration // render as seconds
  readHeaderTimeoutMS: Duration // render as milliseconds
  children: Listing<ServerConfig>
}

output {
  renderer {
    converters {
      ["clientConfig.timeoutS"] = (it) -> it.timeoutS.toUnit("s").value
      ["serverConfig.readTimeoutS"] = (it) -> it.readTimeoutS.toUnit("s").value
      ["serverConfig.readHeaderTimeoutMS"] = (it) -> it.readHeaderTimeoutMS.toUnit("ms").value
      // these are a bit inexact:
      ["children[*].readTimeoutS"] = this["serverConfig.readTimeoutS"]
      ["children[*].readHeaderTimeoutMS"] = this["serverConfig.readHeaderTimeoutMS"]

      // OR

      [ClientConfig] = (it) -> it.toMap().put("timeoutS", it.timeoutS.toUnit("s").value)
      [ServerConfig] = (it) ->
        it
          .toMap()
          .put("readTimeoutS", it.readTimeoutS.toUnit("s").value)
          .put("readHeaderTimeoutMS", it.readHeaderTimeoutMS.toUnit("ms").value)
    }
  }
}
----

== Proposed Solution

To better serve this use case, we propose adding a new type of converter based on property annotations alongside the existing class- and path-based converters.

== Detailed design

=== Pkl API

A new `annotationConverters` property will be added to link:{uri-stdlib-BaseValueRenderer}[`BaseValueRenderer`].

Annotation converters to apply before values are rendered.

Annotation converters are checked for each property of rendered `Typed` values.
If a property has an annotation for which a converter is defined, the converter function is called with the value of the annotation, the property name, and the property value.
The converter function should return a link:{uri-stdlib-Pair}[Pair] of the converted property name and value.
If the returned value is a link:{uri-stdlib-RenderDirective}[RenderDirective], the renderer will output its contents verbatim.
If the renderer produces newlines and indentation, the directive's content is rendered with the same whitespace as sibling properties.

Each of the property annotations of the enclosing class is checked in order, starting with the annotations (top to bottom) of the current class, then repeating for each parent class in the hierarchy.
At most one annotation converter can apply per property; checking concludes after the first annotation that matches a converter.
When an annotation matches multiple converters, the most specific class (according to class hierarchy) wins.

Annotation converters can overlap with link:{uri-stdlib-BaseValueRenderer}#converters[`converters`] and apply first.

[source,pkl]
----
abstract class BaseValueRenderer {
  // ...

  annotationConverters: Mapping<
    Class,
    (Annotation, String, unknown) -> Pair<String, Any> | RenderDirective,
  >

  // ...
}
----

=== Usage Examples

The same scenarios above become simple to implement and maintain with annotation converters:

* *Transforming property names*
+
[source,pkl]
----
class SnakeCase extends Annotation {
  function transform(value: String): String =
    value.replaceAllMapped(Regex("([a-z0-9])([A-Z])"), (match) ->
      "\(match.groups[1].value)_\(match.groups[2].value.toLowerCase())"
    )
}

class Bird {
  @SnakeCase
  birdName: String
}

output {
  renderer {
    annotationConverters {
      [SnakeCase] = (name, annotation, value) -> Pair(annotation.transform(name), value)
    }
  }
}
----
* *Converting the same type in different ways*
+
[source,pkl]
----
clientConfig: ClientConfig

serverConfig: ServerConfig

class ClientConfig {
  @RenderDuration { unit = "s" }
  timeoutS: Duration
}

class ServerConfig {
  @RenderDuration { unit = "s" }
  readTimeoutS: Duration
  @RenderDuration { unit = "ms" }
  readHeaderTimeoutMS: Duration
  children: Listing<ServerConfig>
}

class RenderDuration extends Annotation {
  unit: DurationUnit

  function transform(value: Duration): Number = value.toUnit(unit).value
}

output {
  renderer {
    annotationConverters {
      [RenderDuration] = (annotation, name, value) -> Pair(name, annotation.transform(value))
    }
  }
}
----

== Compatibility

This is a purely additive change.
Modules that adopt annotation converters will not be compatible with prior versions of Pkl.

== Future Directions

=== Default property name converters for built-in renderers

It's often desirable to transform property names (see "Transforming property names" above) differently for different rendered formats.
For example, a property may be named with `snake_case` when rendered to JSON and `kebab-case` when rendered to YAML.

New APIs for per-format property renaming could be added for each built-in renderer that has a corresponding module:

|===
|Renderer Type |Property Annotation Type

|`base.JsonRenderer` |`json.Property`
|`base.YamlRenderer` |`yaml.Property`
|`jsonnet.Renderer`  |`jsonnet.Property`
|`protobuf.Renderer` |`protobuf.Property`
|`xml.Renderer`      |`xml.Property`

|===

Usage example:

.fmt.pkl
[source,pkl]
----
import "pkl:json"
import "pkl:yaml"

@json.Property { name = "foo_bar" }
@yaml.Property { name = "foo-bar" }
fooBar: String = "hello world"
----

[source,terminaloutput]
----
$ pkl eval fmt.pkl -f json
{
  "foo_bar": "hello world"
}

$ pkl eval fmt.pkl -f yaml
foo-bar: hello world
----

Each renderer class would add its corresponding `<format>.Property` annotation as an annotation converter by default in its Pkl definition.
If desired, users could override this default to disable or modify the behavior.

Renderers in `pkl:base` without a corresponding module (`PcfRenderer`, `PropertiesRenderer`, and `PlistRenderer`) would likey not receive corresponding annotations at this time.
A corresponding annotation for `pklbinary.Renderer` should also be omitted; the `pkl-binary` format is not intended to deviate from the native Pkl representation of `Typed` values, which is antithetical to property renaming.

This was formerly part of this proposal, but was deferred because it was not clear how to make this discoverable and explicit without usability pitfalls stemming from default object values in classes.

== Related Topics

=== Converters providing validation

One of the possible applications of converters (annotation-, class-, or path-based) is implementing validations that require non-`const` "global" information.
A prime example of this is modules that support multiple versions of some software.
These modules would likely want to enforce the availability of properties based on a user-supplied "target version" of the software.
This  would be applicable to existing modules like https://pkl-lang.org/package-docs/pkg.pkl-lang.org/pkl-pantry/io.prometheus/current/index.html[`io.prometheus`] or https://pkl-lang.org/package-docs/pkg.pkl-lang.org/pkl-k8s/k8s/current/index.html[`pkl-k8s`] (which already provides an https://pkl-lang.org/package-docs/pkg.pkl-lang.org/pkl-k8s/k8s/current/K8sObject/K8sVersion.html[annotation for version availability]).

The Pkl team views this use of converters as an antipattern primarily because it restricts consumers of a module use its renderer to perform validation.
Users of Pkl's language bindings often bypass rendering entirely and consume the evaluated module value directly, which would bypass this style of validation.
While it's possible to work around this use the xref:SPICE-0021-binary-renderer-and-parser.adoc[`pkl-binary`] renderer and evaluate a module's `output.bytes` property, this requires tighter coupling between a module and how it is consumed than desired.

This sort of validation is something the team is interested in ergonomic support for, but is not a use case well-served by this proposal.

== Alternatives considered

=== Reusing `BaseValueRenderer#converters`

The first iteration of this design opted for reusing the existing `converters` property instead of adding the `annotationConverters` property:

[source,pkl]
----
abstract class BaseValueRenderer {
  // ...

  converters: Mapping<
    Class | String,
    (unknown) -> Any | (Annotation, String, unknown) -> Pair<String, Any>,
  >

  // ...
}
----

The runtime could identify which converters apply to annotations vs. classes by checking the number of arguments for the supplied function.
For functions with 3 arguments the class would be validated to ensure it is a subclass of `Annotation`.

The disadvantage of this approach is that it becomes impossible to define both a class-based and annotation-based converter for the same `Annotation` subclass.
While this unlikely to be an issue in practice, the design as proposed both avoids this limitation and involves less implicit behavior that users would need to track.

=== Special `Annotation` subclass for converting

A new subclass of `Annotation` could be introduced to make working with annotation converters more convenient.

[source,pkl]
----
abstract class ConverterAnnotation extends Annotation {
  function convert(propertyName: String, value: Any): Pair<String, Any> =
    Pair(convertKey(propertyName), convertValue(value))

  function convertKey(propertyName: String): String = propertyName

  function convertValue(value: Any): Any = value
}
----

There are two ways this class might be used:

==== Implicit

Instead of or in addition to explicitly configuring converters that act on annotations, `ConverterAnnotation` could be implicitly treated as a converter:
When rendered, the `convert` method of `ConverterAnnotation` subclasses would be called.

This approach is both more implicit and less capable than the proposed implementation.
There would be no way to only enable specific converter annotations or enable different converters for different renderers.

Even if this approach were expanded to require explicitly listing the `ConverterAnnotation` classes to enable, it would still not be possible to inject module-level data to influence the converter's behavior.

==== Explicit

The `AnnotationConverter` class would be provided as a convenience for implementing annotation converters, especially those that just transform property keys or values, not both.
The converter would still need to be explicitly configured on the renderer:

[source,pkl]
----
annotationConverters {
  [SomeAnnotationConverter] = (annotation, name, value) -> annotation.convert(name, value)
}
----

This adds an identifier to `pkl:base` and would be a breaking change to code using the identifier `AnnotationConverter`.
There is no reason this must be in the standard library; users or libraries making use of annotation converters could define this same class or similar in their own code as-needed.
