:uri-package-docs: https://pkl-lang.org/package-docs
:uri-bindings-specification: {uri-docs}/bindings-specification/binary-encoding.html
:uri-stdlib-baseModule: {uri-package-docs}/pkl/current/base
:uri-stdlib-Annotation: {uri-stdlib-baseModule}/Annotation
:uri-stdlib-BaseValueRenderer: {uri-stdlib-baseModule}/BaseValueRenderer
:uri-stdlib-Typed: {uri-stdlib-baseModule}/Typed
:uri-stdlib-Pair: {uri-stdlib-baseModule}/Pair

= Annotation converters

* Proposal: link:./SPICE-0024-annotation-converters.adoc[SPICE-0024]
* Author: https://github.com/HT154[Jen Basch]
* Status: TBD
* Implemented in: Pkl 0.31
* Category: Language, Standard Library

== Introduction

This proposal introduces a mechanisms to use link:{uri-stdlib-Annotation}[`Annotations`] in link:{uri-stdlib-BaseValueRenderer}[value renderers] to declaratively transform property names and values of link:{uri-stdlib-Typed}[`Typed`] objects during rendering

== Motivation

Today, Pkl's renderers (subclasses of link:{uri-stdlib-BaseValueRenderer}[`BaseValueRenderer`]) offer link:{uri-stdlib-BaseValueRenderer}#converters[`converters`] to transform values during rendering based on their class or "path" through the rendered value.
This functionality is fairly flexible, but there are some use cases that remain difficult or impossible to achieve:

* *Transforming property names* is possible, but only by using a converter on the surrounding value, converting it to a `Map`, and transforming entries.
+
[source,pkl]
----
class Bird {
  birdName: String
}

output {
  renderer {
    converters {
      // replace "birdName" with "bird_name"
      [Bird] = (it) ->
        it
          .toMap()
          .mapKeys((name) ->
            name.replaceAllMapped(Regex("([a-z0-9])([A-Z])"), (match) ->
              "\(match.groups[1].value)_\(match.groups[2].value.toLowerCase())"
            )
          )
    }
  }
}
----
* *Converting the same type in different ways* is possible in some cases using path-based converters or by converting containing classes.
Both of these approaches separate the presentation from the definition, making the code more difficult to understand and maintain.
+
[source,pkl]
----
clientConfig: ClientConfig

serverConfig: ServerConfig

class ClientConfig {
  timeoutS: Duration // render as seconds
}

class ServerConfig {
  readTimeoutS: Duration // render as seconds
  readHeaderTimeoutMS: Duration // render as milliseconds
  children: Listing<ServerConfig>
}

output {
  renderer {
    converters {
      ["clientConfig.timeoutS"] = (it) -> it.timeoutS.toUnit("s").value
      ["serverConfig.readTimeoutS"] = (it) -> it.readTimeoutS.toUnit("s").value
      ["serverConfig.readHeaderTimeoutMS"] = (it) -> it.readHeaderTimeoutMS.toUnit("ms").value
      // these are a bit inexact:
      ["children[*].readTimeoutS"] = this["serverConfig.readTimeoutS"]
      ["children[*].readHeaderTimeoutMS"] = this["serverConfig.readHeaderTimeoutMS"]

      // OR

      [ClientConfig] = (it) -> it.toMap().put("timeoutS", it.timeoutS.toUnit("s").value)
      [ServerConfig] = (it) ->
        it
          .toMap()
          .put("readTimeoutS", it.readTimeoutS.toUnit("s").value)
          .put("readHeaderTimeoutMS", it.readHeaderTimeoutMS.toUnit("ms").value)
    }
  }
}
----

== Proposed Solution

To better serve this use case, we propose adding a new type of converter based on property annotations alongside the existing class- and path-based converters.

== Detailed design

=== Pkl API

A new `annotationConverters` property will be added to link:{uri-stdlib-BaseValueRenderer}[`BaseValueRenderer`].

Annotation converters to apply before values are rendered.

Annotation converters are checked for each property of rendered `Typed` values.
If a property has an annotation for which a converter is defined, the converter function is called with the property name, the value of the annotation, and the property value.
The converter function must return a `Pair` of the converted property name and value.

Each of the property annotations of the enclosing class is checked in order, starting with the annotations (top to bottom) of the current class, then repeating for each parent class in the hierarchy.
Multiple annotation converters can apply; converters for matching annotations are called in order, with the result of one being passed to the next.

At most one converter is applied per annotation. The most specific class (according to class hierarchy) wins.

Annotation converters can overlap with link:{uri-stdlib-BaseValueRenderer}#converters[`converters`] and apply first.

[source,pkl]
----
abstract class BaseValueRenderer {
  // ...

  annotationConverters: Mapping<Class, (String, Annotation, unknown) -> Pair<String, Any>>

  // ...
}
----

=== Usage Examples

The same scenarios above become simple to implement and maintain with annotation converters:

* *Transforming property names*
+
[source,pkl]
----
class SnakeCase extends Annotation {
  function transform(value: String): String =
    value.replaceAllMapped(Regex("([a-z0-9])([A-Z])"), (match) ->
      "\(match.groups[1].value)_\(match.groups[2].value.toLowerCase())"
    )
}

class Bird {
  @SnakeCase
  birdName: String
}

output {
  renderer {
    annotationConverters {
      [SnakeCase] = (propertyName, annotation, value) ->
        Pair(annotation.transform(propertyName), value)
    }
  }
}
----
* *Converting the same type in different ways*
+
[source,pkl]
----
clientConfig: ClientConfig

serverConfig: ServerConfig

class ClientConfig {
  @RenderDuration { unit = "s" }
  timeoutS: Duration
}

class ServerConfig {
  @RenderDuration { unit = "s" }
  readTimeoutS: Duration
  @RenderDuration { unit = "ms" }
  readHeaderTimeoutMS: Duration
  children: Listing<ServerConfig>
}

class RenderDuration {
  unit: DurationUnit

  function transform(value: Duration): Number = value.toUnit(unit).value
}

output {
  renderer {
    annotationConverters {
      [RenderDuration] = (propertyName, annotation, value) ->
        Pair(propertyName, annotation.transform(value))
    }
  }
}
----

== Compatibility

This is a purely additive change.
Modules that adopt annotation converters will not be compatible with prior versions of Pkl.

== Related Topics

=== Converters providing validation

One of the possible applications of converters (annotation-, class-, or path-based) is implementing validations that require non-`const` "global" information.
A prime example of this is modules that support multiple versions of some software.
These modules would likely want to enforce the availability of properties based on a user-supplied "target version" of the software.
This  would be applicable to existing modules like https://pkl-lang.org/package-docs/pkg.pkl-lang.org/pkl-pantry/io.prometheus/current/index.html[`io.prometheus`] or https://pkl-lang.org/package-docs/pkg.pkl-lang.org/pkl-k8s/k8s/current/index.html[`pkl-k8s`] (which already provides an https://pkl-lang.org/package-docs/pkg.pkl-lang.org/pkl-k8s/k8s/current/K8sObject/K8sVersion.html[annotation for version availability]).

The Pkl team views this use of converters as an antipattern primarily because it restricts consumers of a module use its renderer to perform validation.
Users of Pkl's language bindings often bypass rendering entirely and consume the evaluated module value directly, which would bypass this style of validation.
While it's possible to work around this use the xref:SPICE-0021-binary-renderer-and-parser.adoc[`pkl-binary`] renderer and evaluate a module's `output.bytes` property, this requires tighter coupling between a module and how it is consumed than desired.

This sort of validation is something the team is interested in ergonomic support for, but is not a use case well-served by this proposal.

== Future directions

=== Built-in annotations for built-in renderers

One possible extension to annotation converters might be built-in annotations for specific renderers.
These annotation converters could be configured by default on their respective renderers, allowing per-format customization for simple cases without needing to configure any converters directly:

[source,pkl]
----
// fmt.pkl
import "pkl:json"
import "pkl:yaml"

@json.Property { name = "foo_bar" }
@yaml.Property { name = "foo-bar" }
fooBar: String = "hello world"
----

[source,terminaloutput]
----
$ pkl eval fmt.pkl -f json
{
  "foo_bar": "hello world"
}

$ pkl eval fmt.pkl -f yaml
foo-bar: hello world
----

== Alternatives considered

=== Reusing `BaseValueRenderer#converters`

The first iteration of this design opted for reusing the existing `converters` property instead of adding the `annotationConverters` property:

[source,pkl]
----
abstract class BaseValueRenderer {
  // ...

  converters: Mapping<
    Class | String,
    (unknown) -> Any | (String, unknown, unknown) -> Pair<String, Any>,
  >

  // ...
}
----

The runtime could identify which converters apply to annotations vs. classes by checking the number of arguments for the supplied function.
For functions with 3 arguments the class would be validated to ensure it is a subclass of `Annotation`.

The disadvantage of this approach is that it becomes impossible to define both a class-based and annotation-based converter for the same `Annotation` subclass.
While this unlikely to be an issue in practice, the design as proposed both avoids this limitation and involves less implicit behavior that users would need to track.

=== Special `Annotation` subclass for converting

Instead of explicitly configuring converters that act on annotations, a new subclass of `Annotation` could be introduced that is implicitly treated as a converter:

[source,pkl]
----
abstract class ConverterAnnotation extends Annotation {
  function convert(propertyName: String, value: Any): Pair<String, Any>
}
----

When rendered, the `convert` method of `ConverterAnnotation` subclasses would be called implicitly.

This approach is both more implicit and less capable than the proposed implementation.
There would be no way to only enable specific converter annotations or enable different converters for different renderers.

Even if this approach were expanded to require explicitly listing the `ConverterAnnotation` classes to enable, it would still not be possible to inject module-level data like the validation use case outlined above.
