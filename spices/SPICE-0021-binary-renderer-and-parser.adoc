:uri-docs: https://pkl-lang.org/main/current
:uri-bindings-specification: {uri-docs}/bindings-specification/binary-encoding.html
:uri-message-passing-api: {uri-docs}/bindings-specification/message-passing-api.html
:uri-package-docs: https://pkl-lang.org/package-docs
:uri-stdlib-baseModule: {uri-package-docs}/pkl/current/base
:uri-stdlib-Class: {uri-stdlib-baseModule}/Class
:uri-stdlib-TypeAlias: {uri-stdlib-baseModule}/TypeAlias
:uri-stdlib-Function: {uri-stdlib-baseModule}/Function
:uri-deepToTyped: {uri-package-docs}/pkg.pkl-lang.org/pkl-pantry/pkl.experimental.deepToTyped/current/deepToTyped/index.html
:uri-messagepack-spec: https://github.com/msgpack/msgpack/blob/master/spec.md
:uri-messagepack-str: {uri-messagepack-spec}#str-format-family
:uri-messagepack-ext: {uri-messagepack-spec}#ext-format-family

= Binary renderer and parser

* Proposal: link:./SPICE-0021-binary-renderer-parser.adoc[SPICE-0021]
* Author: https://github.com/HT154[Jen Basch]
* Status: Accepted or Rejected
* Implemented in: Pkl 0.30
* Category: Language, Standard Library

== Introduction

Pkl provides a {uri-bindings-specification}[binary encoding format] as part of its {uri-message-passing-api}[message passing API].
This format encodes fully evaluated Pkl data without the loss of explicit type information characteristic of formats like JSON, YAML, and Pcf.

This SPICE proposes new standard library and Java APIs for rendering and parsing the binary encoding format, which this proposal will refer to as `pkl-binary`.

== Motivation

Currently, the only way to render the result of Pkl evaluation to this format is to use the message passing API via a language binding library.
An example of this workflow can be seen in link:https://github.com/apple/pkl-go-examples/tree/main/buildtimeeval[pkl-go-examples].

However, there are several workflows where it would be useful to produce `pkl-binary`-encoded data within Pkl code:

* Runtime loading of deploy-time rendered configuration data using language binding libraries.
** A project using `pkl-go` or `pkl-swift` might prefer to use Pkl to define its configuration schema but not want to actually _evaluate_ Pkl at runtime.
** Instead, the application's configuration might be rendered to `pkl-binary`, deployed with the app (eg. via link:https://kubernetes.io/docs/concepts/configuration/secret/[Kubernetes Secrets]), and loaded during application startup.
** This avoids the requirement that the Pkl executable be present at runtime and avoids lossy intermediate formats like JSON that may not work in all cases (eg. polymorphism).
* Optimized reuse of complex evaluation.
** Large amounts of intermediate state may be serialized to disk as `pkl-binary` and efficiently re-loaded later.
** This avoids serializing to lossy formats like JSON and inefficient or error-prone "re-hydration" of typed Pkl values on load using `toTyped()` or {uri-deepToTyped}[`deepToTyped`].
* And more!

== Proposed Solution

New Pkl and Java APIs will be added to supporting rendering and parsing `pkl-binary` data.
The encoding specification will also be amended to cover encoding/decoding of `Class` and `TypeAlias` values and to define expected behavior of clients around specification changes.

== Detailed design

=== Binary encoding

New language will be added to the {uri-bindings-specification}[specification] requiring implementations to handle values encoded as fixed-length arrays with more slots than expected by either ignoring (skipping) unknown fields or providing helpful errors.

> Additional slots may be added to types in future Pkl releases. Decoders *must* be designed to defensively discard values beyond the number of known slots for a type or provide meaningful error messages.

Additional specificity will be added to define exactly how type names are encoded:

> * When the module URI is `pkl:base`:
> ** If the type name is `ModuleClass`, this type represents the module class of `pkl:base`.
> ** Otherwise, the type name corresponds to a type in `pkl:base`.
> * For all other module URIs:
> ** When the type name contains `\#`, the string after the `#` character corresponds to a type in that module. The string before the `#` is the name of the module.
> ** Otherwise, the type name is the name of the module and represents the class of the module.

Encoding `Class` and `TypeAlias` values now require three slots (previously one) additionally storing the module URI and name of the type.

|===
|Pkl type |Slot 1 2+|Slot 2 2+|Slot 3 2+|Slot 4

||code |type |description |type |description |type |description

|link:{uri-stdlib-Class}[Class]
|`0x0C`
|link:{uri-messagepack-str}[str]
|Class name
|link:{uri-messagepack-str}[str]
|Module URI
|
|

|link:{uri-stdlib-TypeAlias}[TypeAlias]
|`0x0D`
|link:{uri-messagepack-str}[str]
|TypeAlias name
|link:{uri-messagepack-str}[str]
|Module URI
|
|

|===

IMPORTANT: The encoding of link:{uri-stdlib-Function}[Function] values has not changed.
While it is still possible to render these value to `pkl-binary`, the Pkl and Java APIs for parsing `pkl-binary` proposed here will error if decoding is attempted.

=== Pkl API

These changes will be made in the `pkl:base` module:

* `BaseValueRenderer` is a new abstract class defining properties common to textual and binary renderers.
* `ValueRenderer` now extends `BaseValueRenderer`.
* `BytesRenderer` is new abstract class extending `BaseValueRenderer` defining methods for rendering documents and values as `Bytes`.
* `FileOutput.renderer` now accepts any `BaseValueRenderer` and its `bytes` and `text` properties are updated accordingly.
* `module.output.renderer` now provides `pkl-binary` as a possible output format via the `pkl eval --format` flag.

These new Pkl APIs will be added to a new stdlib module `pkl:encoding`:

[source,pkl]
----
module pkl.encoding

/// Render values as the [`pkl-binary` encoding format](https://pkl-lang.org/main/current/bindings-specification/binary-encoding.html).
class PklBinaryEncodingRenderer extends BytesRenderer {
  /// Render a Pkl value as `pkl-binary`.
  external function renderValue(value: Any): Bytes

  /// Render a Pkl document as `pkl-binary`.
  external function renderDocument(value: Any): Bytes
}

/// Parse the [`pkl-binary` encoding format](https://pkl-lang.org/main/current/bindings-specification/binary-encoding.html).
class PklBinaryEncodingParser {
  /// Parse `pkl-binary` data and return the original value.
  ///
  /// This operation will attempt to import any modules, classes or typealiases present in the data.
  /// Imports are subject to the standard [import security checks](https://pkl-lang.org/main/current/language-reference/index.html#security-checks).
  ///
  /// Cannot decode [Function] values.
  external function parse(source: Resource|Bytes): Any
}
----

[WARNING]
====
The security checks performed during in-language binary decoding are not identical to the ones performed by an actual import.
Specifically, checking of trust levels is skipped.
This means that an imported module could construct and parse a `pkl-binary` payload to obtain `Typed`, `Class`, or `TypeAlias` values it would ordinarily be forbidden from obtaining directly.

The Pkl team views this as acceptable.
The trust levels mechanism is largely untouched from the early days of the language (ca. 2017) and no longer serves its original purpose of enforcing security invariants.
Today, the allowed modules mechanism provides for tighter control over which modules may be loaded.
We intend to revisit trust levels in the future.
====

=== Java API

To support the new Pkl APIs for rendering binary data (`BytesRenderer`) and `pkl-binary` specifically (`PklBinaryEncodingRenderer`), the `org.pkl.core.stdlib.AbstractRenderer` class will have all `String`-specific functionality extracted to a new `AbstractStringRenderer` subclass.
Existing `AbstractRenderer` subclasses in the codebase will subclass `AbstractStringRenderer` instead.

A new class `org.pkl.core.PklBinaryDecoder` will be added to implement decoding of `pkl-binary` data to user-facing values (`PObject` and friends):

[source,java]
----
/**
 * A decoder/parser for the <a
 * href="https://pkl-lang.org/main/current/bindings-specification/binary-encoding.html"><code>
 * pkl-binary</code></a> encoding. Returns "exported" value types like PObject, Map, List, and
 * primitives.
 */
public class PklBinaryDecoder extends AbstractPklBinaryDecoder {

  private PklBinaryDecoder(MessageUnpacker unpacker) {
    super(unpacker);
  }

  /**
   * Decode a value from the supplied byte array.
   *
   * @return the encoded value
   */
  public static Object decode(byte[] bytes);

  /**
   * Decode a value from the supplied {@link ByteArrayInputStream}.
   *
   * @return the encoded value
   */
  public static Object decode(ByteArrayInputStream inputStream);

  /**
   * Decode a value from the supplied {@link MessageUnpacker}.
   *
   * @return the encoded value
   */
  public static Object decode(MessageUnpacker unpacker);
}
----

NOTE: This proposal opts not to implement a binary encoder that operates on exported value types, i.e. encoding `PObject` and friends to `pkl-binary`.
This is primarily because exporting runtime values (`Vm*` types) or decoding `pkl-binary` to API values (`P*` types) is a lossy operation.
Pkl `List`/`Listing` and `Map`/`Mapping` values are exported/decoded to the same Java values (`List` and `Map`, respectively), making round-tripping impossible.

A new `org.pkl.config.java.ConfigPklBinaryDecoder` class will be added to adapt binary decoding to link:{uri-docs}/java-binding/pkl-config-java.html#usage[existing Java configuration workflows].
[source,java]
----
var encodedData; // some byte[], ByteBufferInputStream, or MessageUnpacker
Config config;
try (var decoder = ConfigPklBinaryDecoder.preconfigured()) {
  config = decoder.decode(encodedData);
}
var pigeon = config.get("pigeon");
var age = pigeon.get("age").as(int.class);
var diet = pigeon.get("diet").as(JavaType.listOf(String.class));
----

Extensions will be added in `pkl-config-kotlin` to provide equivalent support for link:{uri-docs}/kotlin-binding/pkl-config-kotlin.html#usage[existing Kotlin configuration workflows].
[source,kotlin]
----
val encodedData // some ByteArray, ByteBufferInputStream, or MessageUnpacker
val evaluator = ConfigPklBinaryDecoder.preconfigured().forKotlin()
val config = evaluator.use {
  it.decode(encodedData)
}
val pigeon = config["pigeon"]
val age = pigeon["age"].to<Int>()
val hobbies = pigeon["diet"].to<List<String>>()
----

NOTE: Java classes implementing encoding/decoding of `pkl-binary` to runtime values (`Vm*` types) will be added to `pkl-core` but not exposed as public API.
These types provide the internal implementation of the Pkl renderer/parser APIs.

== Compatibility

These changes are potentially backwards-incompatible

* Subclasses of `org.pkl.core.stdlib.AbstractRenderer` outside of `pkl-core` will need to switch to extend `AbstractStringRenderer`.
* Handling of superfluous slots in fixed-length structures in `pkl-binary` may impact language binding library implementations.
** link:https://github.com/apple/pkl-go/pull/167[Fixed in pkl-go], to be released as part of v???.
** pkl-swift already handles this cleanly.
* The `pkl-binary` encoding now uses two additional (three total) slots for the `Class` and `TypeAlias` types.
** Libraries should support the prior one-slot encoding gracefully to remain compatible with older Pkl releases.

== Future directions

This proposal explicitly avoids proposing a versioning mechanism for the `pkl-binary` encoding in favor of formalizing forward compatibility for a subset of changes (adding fields to fixed-size structures).
In the future, it may be necessary to make changes that do not fall into this category and are truly backwards-incompatible.
This implies that some notion of protocol versioning may be necessary eventually.
There are a few approaches were considered as part of this proposal:

* Out-of-band version indication - Indicate the protocol version in a structure outside the actual encoded byte stream (possibly via a field in the message passing API or a file extension).
* In-band binary header - Indicate the protocol version with a fixed-sized link:https://en.wikipedia.org/wiki/File_format#Magic_number[magic number] such as `PKL<UInt8>` where the integer is the protocol version.
** Implementers would check encoded data for this header and choose an appropriate decoder implementation, falling back to the current "version zero" implementation if the header is not present.
* In-band msgpack data - Indicate the protocol version as encoded msgpack data. Using a {uri-messagepack-ext}[msgpack extension] may make sense as a way to do this.
** Similarly to the binary header, implementers would fall back to the current implementation when no version information is present.

All of these mechanisms would require support in language binding libraries and other consumers of `pkl-binary` data.
In the case of each, this would render older libraries (or Pkl versions) unable to decode `pkl-binary` data encoded by newer Pkl versions, but should allow consumers to still decode data encoded by older Pkl versions.
